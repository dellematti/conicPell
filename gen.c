
// funzione che genera le chiavi. Genera sia la chiave pubblica che la chiave privata e le restituisce in un unica struct
Keys gen(int n) {    

    mpz_t p;       
    mpz_init(p);  
    mpz_t q;       
    mpz_init(q);

    clock_t tick;
    long seed;     

    time_t mytime = time(0);           // IL TEMPO ATTUALE NON BASTA PER AVERE UN SEED AFFIDABILE     IMPORTANTE !!!!!!
    tick = clock();
    seed = tick;          // fare combinazioni tra clock e time? 

    gmp_randstate_t state;
    gmp_randinit_default(state);         //diverse funzioni per Random State Initialization, provare anche le altre
    // gmp_randseed_ui(state,mytime);       
    gmp_randseed_ui(state,seed);    
    // gmp_randseed(state, p);     


    // int n = 512;   //  int oppure mp_bitcnt_t    (per scegliere altro per ora modifico qua)
    // n = 18;     // n deve essere > 18 sennò non funziona (in python la stessa cosa)
    if (n == 512) {
        char str[] = "12948321689330283161097309069531008617676170438141861154869888117631594925133496804116121842848834853210714567795846339617837614889766598764879458136968853";
        mpz_set_str(q, str, 10);
        char strP[] = "6474160844665141580548654534765504308838085219070930577434944058815797462566748402058060921424417426605357283897923169808918807444883299382439729068484427";
        mpz_set_str(p, strP, 10);
    } else if(n == 7680){
        char str[] = "40675856236854884365635268877402285427359338763187328278413549539226827624591756983685418600237252090492584017445765356120599301636842979281970102818198233683611773172690503343343208832013944541412412020028162612560397863056904670493331830823130845685886453609547905146074547930062946081368309337380880577179097714759274926358540340303532694585814180285926826178316885728355448784711402239353043862286867140399643226639297352781981931014207185549059843554384235600006073771503665610024351546615855880063660472164035700302397982972338765811837916946145844114643719885199222112672271032709899025415609337828063321845530723692110603070023414886955618778943936557750662975836347630549304390035828415218211193643960803117442098638447344176118826572389906759271108007964114314652079984348012799041229305514659969743239695671892171906489795472489317142493047860207558868983162946304736856368955395844462010803148029530683917494689450610135814744100743187441945760705005889154371840262136719184279259719695602114916912900472076977078684063809221884593007945005399085119696480207451630028377815896768731618228814657732016577259360877613086301670087528712072082174384742912999406121929995433159560826980890731473908467934770750555816031203861419471020208895514226730300863075972207327076635007480568210300363293686984551841490176994108459629591105025715873407762671197677042995102601821876611940674826426762120766408360436716053130221743904964766928390498361697679250635958838766104319914072171636522288119415770229479099482385954731998066393358898581722224683017758900857215990385773199162581752255389214550854852018870143852264607380877902694473152619129930131014183549994024861934033818999102822617434495395065422495029692126521845110458749311793787602906500810482313381137521822480545415378405753675796879479180180319445615501115786700880024562169992328390460541840360032997724497673119438768321600823864003728682760916033979209318868952960904214821711989475428940945116812861501826168514418816582688005231514156600393417625584077899138147630621718078848957630100547823124542173121417327887135303166086078796843376997353950504487649769068850400740437114899400293743336003258368107225071104978710694685788364145420818482421251483696200459553593808530298209269515695184828870167233440352021127876574440236494221725415713";
        mpz_set_str(q, str, 10);
        char strP[] = "20337928118427442182817634438701142713679669381593664139206774769613413812295878491842709300118626045246292008722882678060299650818421489640985051409099116841805886586345251671671604416006972270706206010014081306280198931528452335246665915411565422842943226804773952573037273965031473040684154668690440288589548857379637463179270170151766347292907090142963413089158442864177724392355701119676521931143433570199821613319648676390990965507103592774529921777192117800003036885751832805012175773307927940031830236082017850151198991486169382905918958473072922057321859942599611056336135516354949512707804668914031660922765361846055301535011707443477809389471968278875331487918173815274652195017914207609105596821980401558721049319223672088059413286194953379635554003982057157326039992174006399520614652757329984871619847835946085953244897736244658571246523930103779434491581473152368428184477697922231005401574014765341958747344725305067907372050371593720972880352502944577185920131068359592139629859847801057458456450236038488539342031904610942296503972502699542559848240103725815014188907948384365809114407328866008288629680438806543150835043764356036041087192371456499703060964997716579780413490445365736954233967385375277908015601930709735510104447757113365150431537986103663538317503740284105150181646843492275920745088497054229814795552512857936703881335598838521497551300910938305970337413213381060383204180218358026565110871952482383464195249180848839625317979419383052159957036085818261144059707885114739549741192977365999033196679449290861112341508879450428607995192886599581290876127694607275427426009435071926132303690438951347236576309564965065507091774997012430967016909499551411308717247697532711247514846063260922555229374655896893801453250405241156690568760911240272707689202876837898439739590090159722807750557893350440012281084996164195230270920180016498862248836559719384160800411932001864341380458016989604659434476480452107410855994737714470472558406430750913084257209408291344002615757078300196708812792038949569073815310859039424478815050273911562271086560708663943567651583043039398421688498676975252243824884534425200370218557449700146871668001629184053612535552489355347342894182072710409241210625741848100229776796904265149104634757847592414435083616720176010563938287220118247110862707857";
        mpz_set_str(p, strP, 10);      
    }else {
        int tmp_q;
        n--;    // n va diminuito di 1, serve  tra 2^(n-2) e 2^(n-1)   la funzione restituisce tra n-1 e n 
        do {
            mpz_rrandomb(p,state ,n );
            mpz_nextprime(p,p);   // così mi prende direttamente il primo numero primo dopo p. controllare se va bene ??
            mpz_mul_si(q,p,2);
            mpz_sub_ui(q,q,1);

            // ora dobbiamo controllare che q sia primo. Possiamo fare tante volte il test miller rabin
            tmp_q = mpz_probab_prime_p(q,25);    // il numero di volte potrebbe cambiare in base a n (?)
        } while (tmp_q == 0);  // se tmp = 0 allora sicuramente non è primo
    }
        
    // gmp_randinit_default(state);  
    // seed = clock();                  // serve inizializzarlo più volte?
    // gmp_randseed_ui(state,seed); 

    mpz_t d;       
    mpz_init(d); 
    int jacobiSymbol;    
    do {                  
        // d potrebbe essere uscito uguale a zero o 1, devo scartarli in quel caso. faccio fino a q+2 e sottraggo 2
        mpz_t tmpMax;
        mpz_init(tmpMax);       

        mpz_sub_ui(tmpMax,q,2);
        mpz_urandomm(d,state,tmpMax );
        mpz_add_ui(d,d,2);
        jacobiSymbol = mpz_jacobi(d, q);
    } while ( jacobiSymbol != -1 );  


    mpz_t g;       
    mpz_init(g); 

    mpz_t yG;       
    mpz_init(yG); 

    mpz_t xG;     
    mpz_t k;
    mpz_t xH;
    mpz_t yH;


    for (;;) {
        mpz_urandomm(yG,state,q );            // casuale da 0 a q-1 compresi
        mpz_t square;       
        mpz_init(square);  
        
        mpz_t tmpSquare;       
        mpz_init(tmpSquare);  

        mpz_mul(tmpSquare, yG, yG);   
        mpz_mod(tmpSquare,tmpSquare,q);  
        mpz_mul(tmpSquare, tmpSquare, d);    
        mpz_add_ui(tmpSquare, tmpSquare, 1);    
        
        mpz_mod(square,tmpSquare,q);

        if (mpz_jacobi(square, q) == 1) {
            // fare un esposnente random da 0 a 1 
            int max = 1;             // va bene sia 2 1 che  1 0                            
            int min = 0;
            srand(clock()); 
            int esponenteRandom = rand() % (max - min + 1) + min ;  
            int sign = -1;
            for(int i = 0; i < esponenteRandom; i++) {
                sign *= sign;
            }

            mpz_t tmpXg;       
            mpz_init(tmpXg);  
            modSqrt(tmpXg, square, q);
            mpz_mod(tmpXg,tmpXg,q);
            
            mpz_init(xG); 
            mpz_mul_si(xG, tmpXg, sign); 

            mpz_t tmpConic1;       
            mpz_init(tmpConic1);   
            mpz_t tmpConic2;       
            mpz_init(tmpConic2);
            
            mpz_t tmp;
            mpz_init(tmp);
            mpz_set_ui(tmp, 2 );        // Ho diversi tmp che inizializzo, potrei usarne di meno per avere meno istruzioni
            
            conic_pow(tmpConic1,tmpConic2, xG, yG, tmp, d, q);

            int cmpr1 = mpz_cmp_si(tmpConic1, 1);    // vale 0 se sono uguali
            int cmpr2 = mpz_cmp_si(tmpConic2, 0);

            if (cmpr1 != 0 || cmpr2 != 0) {
                conic_pow(tmpConic1,tmpConic2, xG, yG, p, d, q);

                cmpr1 = mpz_cmp_si(tmpConic1, 1);    
                cmpr2 = mpz_cmp_si(tmpConic2, 0);

                if (cmpr1 != 0 || cmpr2 != 0) {
                    
                    mpz_t tmpMax;
                    mpz_init(tmpMax); 
                    mpz_init(k);       

                    mpz_sub_ui(tmpMax,q,-1);
                    mpz_urandomm(k,state,tmpMax );
                    mpz_add_ui(k,k,2);             // k = randrange(2, q + 1),uguale a d ma con q+1 invece di q

                    mpz_init(xH); 
                    mpz_init(yH); 
                    conic_pow(xH,yH, xG, yG, k, d, q);

                    break;
                }
            }
        }
    } 


    PublicKey pk = {
        mpz_get_str(NULL,16,q),
        mpz_get_str(NULL,16,d),
        mpz_get_str(NULL,16,xG),
        mpz_get_str(NULL,16,yG),
        mpz_get_str(NULL,16,xH),
        mpz_get_str(NULL,16,yH)
    };

    SecretKey sk = {
        mpz_get_str(NULL,16,k)
    };

    Keys keys = {
        pk,sk
    };


    //vedere se usare o no clear delle variabili inutilizzate
    // mpz_clear (p);

    return keys;
}


